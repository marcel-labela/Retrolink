/* eslint-disable react-hooks/exhaustive-deps */
import { useEffect, useCallback } from 'react';
import { runOnJS, useSharedValue, withSpring, withTiming } from 'react-native-reanimated';
import { PanningDirectionsEnum } from "../panView";
import useAnimationEndNotifier, { TransitionViewAnimationType } from "./useAnimationEndNotifier";
const TransitionViewDirectionEnum = PanningDirectionsEnum;
export { TransitionViewAnimationType, TransitionViewDirectionEnum };
const DEFAULT_ANIMATION_VELOCITY = 300;
const DEFAULT_ANIMATION_CONFIG = {
  velocity: DEFAULT_ANIMATION_VELOCITY,
  damping: 18,
  stiffness: 100,
  mass: 0.4
};
export default function useAnimatedTransition(props) {
  const {
    hiddenLocation,
    onInitPosition,
    enterFrom,
    exitTo,
    onAnimationStart,
    onAnimationEnd
  } = props; // Has to start at {0, 0} with {opacity: 0} so layout can be measured

  const translationX = useSharedValue(0);
  const translationY = useSharedValue(0);
  const {
    onEnterAnimationEnd,
    onExitAnimationEnd
  } = useAnimationEndNotifier({
    onAnimationEnd
  });

  const getLocation = direction => {
    return {
      x: //@ts-expect-error
      direction && [TransitionViewDirectionEnum.LEFT, TransitionViewDirectionEnum.RIGHT].includes(direction) ? hiddenLocation[direction] : 0,
      y: //@ts-expect-error
      direction && [TransitionViewDirectionEnum.UP, TransitionViewDirectionEnum.DOWN].includes(direction) ? hiddenLocation[direction] : 0
    };
  };

  const initPosition = useCallback((to, animationDirection, callback) => {
    'worklet'; // @ts-expect-error

    if ([TransitionViewDirectionEnum.LEFT, TransitionViewDirectionEnum.RIGHT].includes(animationDirection)) {
      translationX.value = withTiming(to.x, {
        duration: 0
      }, callback); // @ts-expect-error
    } else if ([TransitionViewDirectionEnum.UP, TransitionViewDirectionEnum.DOWN].includes(animationDirection)) {
      translationY.value = withTiming(to.y, {
        duration: 0
      }, callback);
    }

    onInitPosition();
  }, [onInitPosition]);
  useEffect(() => {
    if (!hiddenLocation.isDefault && enterFrom) {
      const location = getLocation(enterFrom);
      initPosition(location, enterFrom, animateIn);
    }
  }, [hiddenLocation.isDefault]);
  const translateTo = useCallback((to, animationDirection, callback) => {
    'worklet'; // @ts-expect-error

    if ([TransitionViewDirectionEnum.LEFT, TransitionViewDirectionEnum.RIGHT].includes(animationDirection)) {
      translationX.value = withSpring(to.x, DEFAULT_ANIMATION_CONFIG, callback); // @ts-expect-error
    } else if ([TransitionViewDirectionEnum.UP, TransitionViewDirectionEnum.DOWN].includes(animationDirection)) {
      translationY.value = withSpring(to.y, DEFAULT_ANIMATION_CONFIG, callback);
    }
  }, []);
  const animateIn = useCallback(() => {
    'worklet';

    if (enterFrom) {
      if (onAnimationStart) {
        runOnJS(onAnimationStart)('enter');
      }

      translateTo({
        x: 0,
        y: 0
      }, enterFrom, onEnterAnimationEnd);
    }
  }, [onEnterAnimationEnd]);
  const animateOut = useCallback(() => {
    'worklet';

    if (exitTo) {
      if (onAnimationStart) {
        runOnJS(onAnimationStart)('exit');
      }

      translateTo(getLocation(exitTo), exitTo, onExitAnimationEnd);
    }
  }, [hiddenLocation, exitTo, onExitAnimationEnd]);
  return {
    animateIn,
    animateOut,
    translation: {
      x: translationX,
      y: translationY
    }
  };
}